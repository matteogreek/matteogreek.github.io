<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Writeups | Matteo Greco</title><link>https://matteogreek.github.io/writeups/</link><atom:link href="https://matteogreek.github.io/writeups/index.xml" rel="self" type="application/rss+xml"/><description>Writeups</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><image><url>https://matteogreek.github.io/media/icon_hua57a06e9c056e3196c06dde0a266966a_404_512x512_fill_lanczos_center_3.png</url><title>Writeups</title><link>https://matteogreek.github.io/writeups/</link></image><item><title>0x41haz</title><link>https://matteogreek.github.io/writeups/thm/0x41haz_writeup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matteogreek.github.io/writeups/thm/0x41haz_writeup/</guid><description>&lt;h3 id="task-1-find-the-password">Task 1: Find the password!&lt;/h3>
&lt;blockquote>
&lt;p>In this challenge, you are asked to solve a simple reversing solution. Download and analyze the binary to discover the password.&lt;/p>
&lt;p>There may be anti-reversing measures in place!&lt;/p>
&lt;/blockquote>
&lt;p>After downloading the attached task file, we can start analyzing it.&lt;/p>
&lt;p>To discover what type of file we are dealing with we run &lt;em>file&lt;/em> command followed by the name of the file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$ file 0x41haz.0x41haz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x41haz.0x41haz: ELF 64-bit MSB *unknown arch 0x3e00* (SYSV)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We discovered that this is a ELF 64bit executable file type but it seems that there are some obfuscation technique in place:
&lt;br>
&lt;strong>MSB &lt;em>unknown arch 0x3e00&lt;/em> (SYSV)&lt;/strong>&lt;/p>
&lt;p>Googling it we can find that to bypass this we can patch the sixth byte from 0x02 to 0x01.
To perform this we can use &lt;em>hexedit&lt;/em> to change the specific byte.&lt;/p>
&lt;p>After changing the sixth byte we get the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">0x41haz.0x41haz: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BuildID[sha1]=6c9f2e85b64d4f12b91136ffb8e4c038f1dc6dcd,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">for GNU/Linux 3.2.0, stripped
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It&amp;rsquo;s time to analyze the file with Ghidra and see what we can discover.
Looking at the functions we discover the below decoded function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">undefined8 FUN_00101165(void)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> size_t sVar1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> char local_48 [42];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> undefined8 local_1e;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> undefined4 local_16;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> undefined2 local_12;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int local_10;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int local_c;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> local_1e = 0x6667243532404032;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> local_16 = 0x40265473;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> local_12 = 0x4c;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> puts(&amp;#34;=======================\nHey , Can You Crackme ?\n=======================&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> puts(&amp;#34;It\&amp;#39;s jus a simple binary \n&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> puts(&amp;#34;Tell Me the Password :&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> gets(local_48);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sVar1 = strlen(local_48);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> local_10 = (int)sVar1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if ((int)sVar1 != 0xd) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> puts(&amp;#34;Is it correct , I don\&amp;#39;t think so.&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /* WARNING: Subroutine does not return */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> exit(0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> local_c = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while( true ) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (0xc &amp;lt; local_c) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> puts(&amp;#34;Well Done !!&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (*(char *)((long)&amp;amp;local_1e + (long)local_c) != local_48[local_c]) break;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> local_c = local_c + 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> puts(&amp;#34;Nope&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /* WARNING: Subroutine does not return */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> exit(0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We found some hex strings, lets decode them using &lt;em>xxd&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">echo 0x6667243532404032 | xxd -r
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo 0x40265473 | xxd -r
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo 0x4c | xxd -r
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>local_1e = 0x6667243532404032; -&amp;gt; fg$52@@2&lt;br>
local_16 = 0x40265473; -&amp;gt; @&amp;amp;Ts&lt;br>
local_12 = 0x4c; -&amp;gt; L&lt;/p>
&lt;p>concatenate them and try the resulting string as input for the password.&lt;/p>
&lt;p>&lt;strong>fg$52@@2@&amp;amp;TsL&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/70201797/166164363-b1d60e03-e187-4707-aa20-52f152000e16.png" alt="try1" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Let&amp;rsquo;s reverse the hex strings to follow the little-endian format and try again.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">echo 0x6667243532404032 | xxd -r | rev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo 0x40265473 | xxd -r | rev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo 0x4c | xxd -r | rev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2@@25$gfsT&amp;amp;@L&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/70201797/166164391-0a17a6f0-ccf9-4ecd-8fe2-d77fd71628b4.png" alt="try2" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>Hurray!&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://matteogreek.github.io" target="_blank" rel="noopener">Heartstone back to home&lt;/a>&lt;/p></description></item><item><title>Committed</title><link>https://matteogreek.github.io/writeups/thm/committed_writeup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matteogreek.github.io/writeups/thm/committed_writeup/</guid><description>&lt;h2 id="task1">Task1&lt;/h2>
&lt;p>Some sensitive code was leaked and committed to a GitHub repository. The goal is to find what was committed.&lt;/p>
&lt;h3 id="question-1">Question 1&lt;/h3>
&lt;blockquote>
&lt;p>Discover the flag in the repository!&lt;/p>
&lt;/blockquote>
&lt;p>Start by deploying the machine attached to the room to access the the files we need. Inside the machine we find &lt;em>committed.zip&lt;/em>.&lt;/p>
&lt;p>We know that we need to find some leaked information on some accidental commit. To know all the past commit to a git repository we can type:&lt;/p>
&lt;blockquote>
&lt;p>git log &amp;ndash;reflog&lt;/p>
&lt;/blockquote>
&lt;p>where reflog is a record of all commits that were referenced in the repo at any time.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/70201797/180622496-e3981949-7483-40ec-a1a2-27152d6d2b97.png" alt="Screenshot_2022-07-23_16-06-10" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Looking through the results one commit stand out with the message text set as &lt;em>Oops&lt;/em>. To show the content of the commit we can use the command:&lt;/p>
&lt;blockquote>
&lt;p>git show &amp;lt;hash&amp;gt;&lt;/p>
&lt;/blockquote>
&lt;p>where &amp;lt;hash&amp;gt; is the hash of the commit that we want to show. It&amp;rsquo;s easy now to find the string with the flag.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
flag{a489a9dbf8eb9d37c6e0cc1a92cda17b}
&lt;/p>
&lt;/details>
&lt;p>&lt;strong>Hurray!&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://matteogreek.github.io/" target="_blank" rel="noopener">Heartstone back home&lt;/a>&lt;/p></description></item><item><title>KAPE</title><link>https://matteogreek.github.io/writeups/thm/kape_writeup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matteogreek.github.io/writeups/thm/kape_writeup/</guid><description>&lt;h2 id="introduction-to-kape">Introduction to KAPE&lt;/h2>
&lt;p>As reported on task 2 of the room:&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Kroll Artifact Parser and Extractor&lt;/em> (KAPE) parses and extracts Windows forensics artifacts. It is a tool that can significantly reduce the time needed to respond to an incident by providing forensic artifacts from a live system or a storage device much earlier than the imaging process completes.&lt;/p>
&lt;p>KAPE serves two primary purposes, 1) collect files and 2) process the collected files as per the provided options. For achieving these purposes, KAPE uses the concept of targets and modules. Targets can be defined as the forensic artifacts that need to be collected. Modules are programs that process the collected artifacts and extract information from them. We will learn about them in the upcoming tasks.&lt;/p>
&lt;/blockquote>
&lt;p>Task 3,4,5,6 explain how the tool works, terminology and a quick example of how to setup.&lt;/p>
&lt;p>Let&amp;rsquo;s focus on task 7 with the &lt;em>Hands-on Challenge&lt;/em>.&lt;/p>
&lt;h2 id="hands-on-challenge">Hands-on Challenge&lt;/h2>
&lt;p>The scenario is the following:&lt;/p>
&lt;blockquote>
&lt;p>Organization X has an Acceptable Use Policy for their Portable Devices, including Laptops. This policy forbids users from connecting removable or Network drives, installing software from unknown locations, and connecting to unknown networks. It looks like one of the users has violated this policy. Can you help Organization X find out if the user violated the Acceptable Use Policy on their device?&lt;/p>
&lt;/blockquote>
&lt;h3 id="setup-the-tool">Setup the tool&lt;/h3>
&lt;p>Let&amp;rsquo;s start by executing &lt;em>gkape.exe&lt;/em> for using the tool with the GUI. Once the application has started we can fill the required parameters. Specifically we have to select the Target options and the Model options.
Starting from the target we select:&lt;/p>
&lt;ol>
&lt;li>Target source: the path to were we want to perform the forensics (e.g C:)&lt;/li>
&lt;li>Target destination: the path were the files will be copied (e.g ~Desktop\kape)&lt;/li>
&lt;li>Targets: select the various collected artifacts. We are interested in connections of removable or network drives, connection to networks and installation of software as stated in the policy above.
So we can search and add the artifacts related to the USB logs (since we need that info for one question) and KapeTriage which collects all the data that have to do with Registry, System files and more.&lt;/li>
&lt;/ol>
&lt;p>On Module options:&lt;/p>
&lt;ol>
&lt;li>Module source: tipically the same path of the target destination (leave blank)&lt;/li>
&lt;li>Module destination: path to were the output is saved.e.g ~Desktop\output)&lt;/li>
&lt;li>Modules: select the various module to use for processing the targets. Here we can select the Eric Zimmerman provided parsers.&lt;/li>
&lt;/ol>
&lt;p>We are now ready to click execute and let Kape do the magic!&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/70201797/178516428-3a543e39-ea6f-4f0a-bccb-d1b93078e584.png" alt="kape1" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="question-1">Question 1&lt;/h3>
&lt;p>We need to find the Serial Number of the other USB Device that was connected to the device. To discover it we search in the output folder generated by Kape. Inside the &lt;em>Registry&lt;/em> directory we can find several &lt;em>.csv&lt;/em> files. The one we are looking for is called &lt;em>DeviceClasses.csv&lt;/em> which contains the devices that were connected to the machine. We can identify the USB by looking at the type column and searching the 2 USB devices.&lt;/p>
&lt;details>
&lt;summary>The serial number of the USB is the following:&lt;/summary>
&lt;p>
1C6F654E59A3B0C179D366AE
&lt;/p>
&lt;/details>
&lt;h3 id="question-2">Question 2&lt;/h3>
&lt;p>We need to find the drive letter and path of the directory from where 7zip, Google Chrome and Mozilla Firefox were installed giving that they come from a network drive location.&lt;/p>
&lt;p>Navigate to
&lt;em>Output/FileFloderAccess/automaticDestination.csv&lt;/em>
to analyze all the file that has been accessed and view the path from which programs were installed.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
Z:\Setups
&lt;/p>
&lt;/details>
&lt;h3 id="question-3">Question 3&lt;/h3>
&lt;p>The next question asks us to find the execution date and time of CHROMESETUP.EXE. To answer we can navigate to &lt;em>Registry/RecentApps.csv&lt;/em> where all recent applications are registered.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
11/25/2021 03:33
&lt;/p>
&lt;/details>
&lt;h3 id="question-4">Question 4&lt;/h3>
&lt;p>What search query was run on the system?
Always inside the Registry folder we can look at &lt;em>WordWheelQuery.csv&lt;/em> to know which queries were run on the system.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
RunWallpaperSetup.cmd
&lt;/p>
&lt;/details>
&lt;h3 id="question-5">Question 5&lt;/h3>
&lt;p>Next question is about when was the network named Network 3 First connected. We can find this information inside &lt;em>Registry/KnownNetworks.csv&lt;/em>
from there we can see Network 3 first and last connection time.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
11/30/2021 15:44
&lt;/p>
&lt;/details>
&lt;h3 id="question-6">Question 6&lt;/h3>
&lt;p>The last question is what removable drive was KAPE copied from. As before we can identify the path inside
&lt;em>FileFloderAccess/AutomaticDestination.csv&lt;/em>&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
E:
&lt;/p>
&lt;/details>
&lt;p>&lt;strong>Hurray!&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://matteogreek.github.io/" target="_blank" rel="noopener">Heartstone back to home&lt;/a>&lt;/p></description></item><item><title>Mr. Phisher</title><link>https://matteogreek.github.io/writeups/thm/mrphisher_writeup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matteogreek.github.io/writeups/thm/mrphisher_writeup/</guid><description>&lt;h2 id="task1">Task1&lt;/h2>
&lt;p>Deploy the machine attached to the room to access the files.&lt;/p>
&lt;h3 id="question-1">Question 1&lt;/h3>
&lt;blockquote>
&lt;p>Uncover the flag in the email attachment!&lt;/p>
&lt;/blockquote>
&lt;p>The task of the room says that the document attached to a suspicious email keeps asking to enable macros.
We can use this information as a guide for starting the research of the flag. We can deduce that some kind of useful information is related to the document&amp;rsquo;s macros.&lt;/p>
&lt;p>First of all let&amp;rsquo;s open the file called &lt;em>MrPhisher.docm&lt;/em> with LibreOffice. Then to see what macros are set for the document go to &lt;em>Tools &amp;gt; Macros &amp;gt; Edit Macros&lt;/em>.
Under &lt;em>Modules&lt;/em> we can see &lt;em>NewMacro&lt;/em>, if we open it we see the macro related of MrPhisher.doc.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/70201797/180665401-31f055cb-5f80-4056-a9d9-a3e45ce1e1a9.png" alt="macro" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>We can note that it&amp;rsquo;s a macro written in Visual Basic. For simplicity we can easily convert the code to python.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://user-images.githubusercontent.com/70201797/180665413-6ece7625-e923-4fdf-8515-eec88e8c4e44.png" alt="code1" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>The code is straightforward, each element of the array is xor-ed with the relative index of that element. The result is casted to char to form the final output.&lt;/p>
&lt;p>Let&amp;rsquo;s run it and see what the result is. Oh wait it&amp;rsquo;s the flag!&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
flag{a39a07a239aacd40c948d852a5c9f8d1}
&lt;/p>
&lt;/details>
&lt;p>&lt;strong>Hurray!&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://matteogreek.github.io/" target="_blank" rel="noopener">Heartstone back home&lt;/a>&lt;/p></description></item><item><title>OhSINT</title><link>https://matteogreek.github.io/writeups/thm/ohsint_writeup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matteogreek.github.io/writeups/thm/ohsint_writeup/</guid><description>&lt;h2 id="task1">Task1&lt;/h2>
&lt;blockquote>
&lt;p>What information can you possible get with just one photo?&lt;/p>
&lt;/blockquote>
&lt;h3 id="question-1">Question 1&lt;/h3>
&lt;p>What profile picture does this user have?&lt;/p>
&lt;p>Let&amp;rsquo;s start by downloading the task files. We can see that the file attached to this room is an image called &lt;em>WindowsXP.jpg&lt;/em>. Let&amp;rsquo;s run &lt;strong>exiftool&lt;/strong> to analyze the metadata of the file and see if we can find some useful information.&lt;/p>
&lt;p>By looking at the result, under the copyright data we can take note of a what it seems a username (OWoodflint).
Since the goal of the room is learn what is OSINT we have to proceed and search on the web the username we just found to obtain publicly available information about the target.&lt;/p>
&lt;p>There are many ways to do it, one is by using &lt;strong>sherlock&lt;/strong> or other OSINT tools that automate the process of finding usernames across many social networks.&lt;/p>
&lt;p>To perform the actual search we can type the following command where &lt;em>–timeout&lt;/em> is the time (in seconds) to wait for response to requests. A longer timeout will increase the likelihood of getting results from slow sites but on the other hand, this may result in a long delay in gathering all the results.&lt;/p>
&lt;blockquote>
&lt;p>python3 sherlock.py OWoodflint –timeout 15&lt;/p>
&lt;/blockquote>
&lt;p>There are multiple accounts with that username registered on various websites, some
of which may not belong to the individual we are looking for. Let’s start by looking at the twitter account. By opening the target’s profile we can answer what the profile picture this account has.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
cat
&lt;/p>
&lt;/details>
&lt;h3 id="question-2">Question 2&lt;/h3>
&lt;blockquote>
&lt;p>What city is this person in?&lt;/p>
&lt;/blockquote>
&lt;p>Looking at the target’s profile we can observe that one tweet contains the BSSID of one of his neighbors.
The BSSID or Basic Service Set Identifier is a unique 48-bit label associated with an individual access point. With this information we can use &lt;strong>Wigle.net&lt;/strong> which is a website that collects location and other data from wireless networks worldwide. Volunteers gather this data by downloading an app to their phones, which registers all APs they meet as well as their GPS coordinates. All of this information is then uploaded into the database. This data is then displayed to viewers on the website.
Let’s try to locate our target. Navigate to Wigle.net and enter the BSSID found on twitter. The result is an address where the city is the answer.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
London
&lt;/p>
&lt;/details>
&lt;h3 id="question-3">Question 3&lt;/h3>
&lt;blockquote>
&lt;p>Whats the SSID of the WAP he connected to?&lt;/p>
&lt;/blockquote>
&lt;p>To answer just look at the result we obtained on Wigle.net for the previous question. In addition to the location there is also the SSID we are looking for.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
UnileverWiFi
&lt;/p>
&lt;/details>
&lt;h3 id="question-4">Question 4&lt;/h3>
&lt;blockquote>
&lt;p>What is his personal email address?&lt;/p>
&lt;/blockquote>
&lt;p>We have to search on other websites to answer this. Let&amp;rsquo;s open the github account related to the same username. We can see a public repository called &lt;em>people_finder&lt;/em>. On the README.md file there is the email address.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
OWoodflint@gmail.com
&lt;/p>
&lt;/details>
&lt;h3 id="question-5">Question 5&lt;/h3>
&lt;blockquote>
&lt;p>What site did you find his email address on?&lt;/p>
&lt;/blockquote>
&lt;p>The name of the site where we found the email address.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
Github
&lt;/p>
&lt;/details>
&lt;h3 id="question-6">Question 6&lt;/h3>
&lt;blockquote>
&lt;p>Where has he gone on holiday?&lt;/p>
&lt;/blockquote>
&lt;p>By googling OWoodflint there is a wordpress website where we can find more information. On the mainpage of the blog there is a post where the author says where he is right now.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
New York
&lt;/p>
&lt;/details>
&lt;h3 id="question-7">Question 7&lt;/h3>
&lt;blockquote>
&lt;p>What is this persons password?&lt;/p>
&lt;/blockquote>
&lt;p>To answer this we need to view the source code of the websites. Looking at the code we can try and search for keywords like &amp;lsquo;psw&amp;rsquo;, &amp;lsquo;password&amp;rsquo; or similar but nothing pops out. looking at the body of the page we can notice a paragraph with the color set to white where the text is a strange string which is the final answer.&lt;/p>
&lt;details>
&lt;summary>Answer:&lt;/summary>
&lt;p>
pennYDr0pper.!
&lt;/p>
&lt;/details>
&lt;p>&lt;strong>Hurray!&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://matteogreek.github.io/" target="_blank" rel="noopener">Heartstone back home&lt;/a>&lt;/p></description></item></channel></rss>